from typing import List, Dict, Any, Optional
import os
from datetime import datetime
from google.adk.sessions import Session, BaseSessionService
from google.genai.types import Content, Part
from supabase import Client

class SupabaseSession(Session):
    def __init__(self, client: Client, session_id: str, user_id: str):
        self.client = client
        self.session_id = session_id
        self.user_id = user_id
        self._messages: List[Content] = []
    
    def load(self) -> List[Content]:
        """Loads messages from Supabase."""
        try:
            response = self.client.table("chat_messages") \
                .select("*") \
                .eq("user_id", self.user_id) \
                .order("created_at", desc=False) \
                .execute()
            
            messages = []
            for record in response.data:
                role = "user" if record["sender"] == "user" else "model"
                # ADK uses 'model' but our DB uses 'cloudinha'. Mapping is needed.
                # Assuming 'cloudinha' is the specific sender name for the bot.
                
                content = Content(
                    role=role,
                    parts=[Part(text=record["content"])]
                )
                messages.append(content)
            
            self._messages = messages
            return messages
        except Exception as e:
            print(f"Error loading session from Supabase: {e}")
            return []

    def save(self, messages: List[Content]):
        """Saves new messages to Supabase."""
        # Simple strategy: save messages that are not yet in DB.
        # However, ADK passes the FULL history to save.
        # We need to filter out what's already saved or just save the new ones (delta).
        # A robust way is to check the length, but concurrent requests might mess that up.
        # Better: Since we load at start of turn, 'messages' contains old + new.
        # We can try to identify new messages.
        
        # Optimization: Only save the last message(s) if we know the flow.
        # But ADK interface is generic.
        
        # Let's count how many we loaded initially vs how many we have now.
        # Ideally, SupabaseSession would track loaded count.
        # But `save` is stateless in the interface usually.
        # Let's rely on checking if it exists or just persist everything? No, that's bad.
        
        # Current strategy: Save ONLY the messages that don't look like they came from DB.
        # But we don't store IDs in Content objects.
        
        # Alternative: We trust that `save` is called with the full list.
        # We can implement a naive delta save:
        # Save messages starting from index `len(self._messages)` (if we update _messages on load)
        # But `save` might be called multiple times.
        
        # Let's try to just save the suffix.
        # The safest for now without complex state tracking is to append the *new* messages 
        # that appeared in this turn. 
        # ADK runner typically calls save after a turn.
        
        existing_count = len(self._messages)
        new_messages = messages[existing_count:]
        
        if not new_messages:
            return

        formatted_records = []
        for msg in new_messages:
            sender = "user" if msg.role == "user" else "cloudinha"
            
            # Extract text from parts
            text_content = ""
            if msg.parts:
                for part in msg.parts:
                    if hasattr(part, 'text') and part.text:
                        text_content += part.text
            
            if not text_content:
                continue

            record = {
                "user_id": self.user_id,
                "sender": sender,
                "content": text_content,
                # "created_at": is auto-generated by DB usually
            }
            formatted_records.append(record)
        
        if formatted_records:
            try:
                self.client.table("chat_messages").insert(formatted_records).execute()
                # Update local cache to include these saved messages so we don't resave them next time
                self._messages.extend(new_messages)
            except Exception as e:
                print(f"Error saving to Supabase: {e}")

class SupabaseSessionService(BaseSessionService):
    def __init__(self, client: Client):
        self.client = client
        self._sessions: Dict[str, SupabaseSession] = {}

    async def create_session(self, app_name: str, session_id: str, user_id: Optional[str] = None) -> Session:
        if not user_id:
             # Fallback or error. For now, matching implementation plan warning.
             # We need user_id for the DB key.
             user_id = session_id # Fallback if user_id missing but session_id present
        
        session = SupabaseSession(client=self.client, session_id=session_id, user_id=user_id)
        # Pre-load? ADK usually calls load() on the session.
        self._sessions[session_id] = session
        return session

    async def get_session(self, app_name: str, session_id: str, user_id: Optional[str] = None) -> Session:
        if session_id in self._sessions:
             return self._sessions[session_id]
        
        # If not in memory (service restarted), recreate it.
        # SupabaseSession is stateless regarding the service, it fetches from DB.
        return await self.create_session(app_name, session_id, user_id)

    async def list_sessions(self, app_name: str) -> List[Session]:
        return list(self._sessions.values())

    async def delete_session(self, app_name: str, session_id: str) -> None:
        if session_id in self._sessions:
            del self._sessions[session_id]
